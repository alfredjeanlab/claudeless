#!/usr/bin/env bun
// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC

//! Generate spec test files from capture fixtures.
//!
//! Reads:
//!   - tests/fixtures/v{VERSION}/*.manifest.json  (capsh script manifests)
//!   - tests/fixtures/v{VERSION}/*.cli.txt        (CLI output fixtures)
//!   - tests/fixtures/v{VERSION}/*.tmux.txt       (tmux fixtures)
//!   - tests/capture/capsh/*.capsh                (original capsh scripts)
//!   - tests/capture/cli/*.cli                    (CLI scripts)
//!   - tests/capture/tmux/*.sh                    (tmux scripts)
//!
//! Writes:
//!   - tests/specs/capsh/*.capsh                  (simplified capsh scripts)
//!   - tests/specs/scenarios/*.toml               (scenario files)
//!   - crates/cli/tests/capsh_specs.rs            (generated Rust tests)
//!   - crates/cli/tests/tmux_specs.rs             (generated Rust tests)
//!   - crates/cli/tests/cli_specs.rs              (generated Rust tests)

import * as fs from "node:fs";
import * as path from "node:path";
import {
  type ExtractedToolCall,
  type ResponseStep,
  type ConversationTurn,
  type CapshManifest,
  extractPlaceholder,
  extractWelcomeBackRightPanel,
  extractConversationTurns,
  detectContextReadsFromFixtures,
} from "./lib/extraction.ts";

const SCRIPT_DIR = path.dirname(new URL(import.meta.url).pathname);
const ROOT = path.resolve(SCRIPT_DIR, "../..");
const FIXTURES_BASE = path.join(ROOT, "tests/fixtures");
const CAPTURE_DIR = path.join(ROOT, "tests/capture");
const SPECS_DIR = path.join(ROOT, "tests/specs");
const RUST_TESTS_DIR = path.join(ROOT, "crates/cli/tests");

const LICENSE_HEADER = `// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC`;

const GENERATED_HEADER = `// AUTO-GENERATED by tests/capture/generate.ts — do not edit manually`;

// --- Detect latest fixture version ---

function detectLatestVersion(): string {
  const entries = fs
    .readdirSync(FIXTURES_BASE)
    .filter((e) => e.startsWith("v") && fs.statSync(path.join(FIXTURES_BASE, e)).isDirectory())
    .sort();
  if (entries.length === 0) {
    throw new Error("No fixture versions found in tests/fixtures/");
  }
  return entries[entries.length - 1];
}

// --- Parse capsh script headers ---

interface ScriptHeaders {
  args: string; // CLI args (empty string = default --model haiku)
  config: "trusted" | "welcome-back" | "auth-only" | "empty";
  timeout: number | null;
}

function parseHeaders(content: string): ScriptHeaders {
  const argsMatch = content.match(/^# Args:\s*(.*)$/m);
  let args = "--model haiku"; // default
  if (argsMatch) {
    const val = argsMatch[1].trim();
    if (val === "(none)" || val === "none") args = "";
    else args = val;
  }

  const configMatch = content.match(/^# Config:\s*(.*)$/m);
  let config: ScriptHeaders["config"] = "trusted";
  if (configMatch) {
    const val = configMatch[1].trim().split(/\s+/)[0];
    if (val === "welcome-back" || val === "auth-only" || val === "empty") {
      config = val;
    }
  }

  const timeoutMatch = content.match(/^# Timeout:\s*(\d+)/m);
  const timeout = timeoutMatch ? Number(timeoutMatch[1]) : null;

  return { args, config, timeout };
}

// --- Simplify capsh scripts ---

/**
 * Parse a duration string from capsh and return milliseconds.
 * Examples: "500" -> 500, "3s" -> 3000, "10s" -> 10000, "2m" -> 120000
 */
function parseDuration(s: string): number {
  if (s.endsWith("m")) return Number(s.slice(0, -1)) * 60000;
  if (s.endsWith("s")) return Number(s.slice(0, -1)) * 1000;
  if (s.endsWith("ms")) return Number(s.slice(0, -2));
  return Number(s);
}

/**
 * Format a duration in milliseconds as a capsh duration string.
 * Uses the most compact representation.
 */
function formatDuration(ms: number): string {
  if (ms >= 1000 && ms % 1000 === 0) return `${ms / 1000}s`;
  return `${ms}`;
}

/**
 * Clamp a wait-for-pattern timeout to max 5s (needs time for app startup + render).
 * Clamp a bare wait (duration) to max 500ms.
 * Clamp inline delays to max 100ms.
 */
function simplifyCapshScript(content: string): string {
  const lines = content.split("\n");
  const output: string[] = [];
  let inConditional = false;
  let inElse = false;
  let inMatch = false;
  let matchTimeout: string | null = null;
  let matchFirstArm: { pattern: string; command: string } | null = null;
  let conditionalDepth = 0;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments (keep header comments)
    if (trimmed === "" || trimmed.startsWith("#")) {
      output.push(line);
      continue;
    }

    // Handle if/else/end blocks — strip conditionals, keep the else branch
    // (the else branch is the "normal" path when claudeless is used, since
    // claudeless doesn't show trust dialogs by default)
    if (trimmed.startsWith("if wait")) {
      inConditional = true;
      inElse = false;
      conditionalDepth++;
      continue;
    }
    if (trimmed === "else" && inConditional) {
      inElse = true;
      continue;
    }
    if (trimmed === "end" && inConditional) {
      conditionalDepth--;
      if (conditionalDepth === 0) {
        inConditional = false;
        inElse = false;
      }
      continue;
    }
    if (inConditional && !inElse) {
      // Skip the if-branch
      continue;
    }
    if (inConditional && inElse) {
      // Keep the else-branch content (will be processed below)
      // Fall through to normal processing
    }

    // Handle match/end blocks — extract first arm's wait pattern + command
    if (trimmed.startsWith("match ")) {
      inMatch = true;
      matchTimeout = trimmed.match(/^match\s+(\d+(?:ms|s|m)?)$/)?.[1] || null;
      matchFirstArm = null;
      continue;
    }
    if (trimmed === "end" && inMatch) {
      inMatch = false;
      // Emit the first arm: wait for the pattern, then run the command
      if (matchFirstArm) {
        const waitTimeout = matchTimeout ? ` ${formatDuration(Math.min(parseDuration(matchTimeout), 5000))}` : " 5s";
        output.push(`wait "${matchFirstArm.pattern}"${waitTimeout}`);
        output.push(matchFirstArm.command);
      }
      matchTimeout = null;
      matchFirstArm = null;
      continue;
    }
    if (inMatch) {
      // Inside match block — capture the first arm's pattern and command
      const armMatch = trimmed.match(/^"([^"]*)"\s*->\s*(.+)$/);
      if (armMatch && !matchFirstArm) {
        matchFirstArm = { pattern: armMatch[1], command: armMatch[2] };
      }
      continue;
    }

    // Process wait commands
    if (trimmed.startsWith("wait ")) {
      const processed = simplifyWait(trimmed);
      output.push(processed);
      continue;
    }

    // Process bare thinking spinner wait pairs: wrap in conditional
    // Detect "wait \w+…" followed by "wait !\w+…" and wrap in if/end
    // (claudeless responds instantly, no spinner appears)
    // This is handled as a post-processing step below

    // Process send commands — clamp inline delays
    if (trimmed.startsWith("send ")) {
      const processed = simplifySend(trimmed);
      output.push(processed);
      continue;
    }

    // Keep everything else as-is (snapshot, kill)
    output.push(trimmed);
  }

  // Post-process: wrap bare thinking spinner wait pairs in if/end blocks.
  // Pattern: `wait "\w+…" Ns` followed by `wait !"\w+…" Ms` → `if wait "\w+…" Ns\n    wait !"\w+…" Ms\nend`
  // This makes the spinner wait conditional (claudeless responds instantly, no spinner).
  const final_output: string[] = [];
  for (let i = 0; i < output.length; i++) {
    const cur = output[i].trim();
    const next = i + 1 < output.length ? output[i + 1].trim() : "";

    if (cur.match(/^wait\s+"[^"]*…"/) && next.match(/^wait\s+!"[^"]*…"/)) {
      final_output.push(`if ${cur}`);
      final_output.push(`    ${next}`);
      final_output.push("end");
      i++; // skip next line (already consumed)
      continue;
    }
    final_output.push(output[i]);
  }

  return final_output.join("\n");
}

/**
 * Simplify a wait command:
 * - `wait "pattern" 30s` → `wait "pattern" 5s`  (pattern waits need time for startup)
 * - `wait !"pattern" 10s` → `wait !"pattern" 5s`
 * - `wait 2s` → `wait 500`                       (bare delays just need to be short)
 * - `wait 100` → `wait 100` (already short)
 */
function simplifyWait(line: string): string {
  const trimmed = line.trim();

  // Bare wait with duration: `wait 500`, `wait 2s`
  const bareWaitMatch = trimmed.match(/^wait\s+(\d+(?:ms|s|m)?)$/);
  if (bareWaitMatch) {
    const ms = parseDuration(bareWaitMatch[1]);
    const clamped = Math.min(ms, 500);
    return `wait ${formatDuration(clamped)}`;
  }

  // Pattern wait: `wait "pattern" 10s` or `wait !"pattern" 10s`
  const patternWaitMatch = trimmed.match(/^(wait\s+!?"[^"]*")\s+(\d+(?:ms|s|m)?)$/);
  if (patternWaitMatch) {
    const prefix = patternWaitMatch[1];
    const ms = parseDuration(patternWaitMatch[2]);
    const clamped = Math.min(ms, 5000);
    return `${prefix} ${formatDuration(clamped)}`;
  }

  // Pattern wait without timeout: `wait "pattern"` — add a reasonable timeout
  const patternOnlyMatch = trimmed.match(/^wait\s+!?"[^"]*"$/);
  if (patternOnlyMatch) {
    return `${trimmed} 5s`;
  }

  return trimmed;
}

/**
 * Simplify a send command — clamp inline delays to 100ms.
 * `send "/help" 100 <Enter>` → `send "/help" 100 <Enter>` (already ≤100)
 * `send <C-u> 200 "/exit" 200 <Enter>` → `send <C-u> 100 "/exit" 100 <Enter>`
 */
function simplifySend(line: string): string {
  // Replace numeric tokens that are standalone delays (between quoted strings or key specials)
  return line.replace(/\s(\d+)\s/g, (match, num) => {
    const ms = Number(num);
    if (ms > 100) return ` 100 `;
    return match;
  });
}


/** Escape a string for use in TOML double-quoted strings. */
function tomlEscape(s: string): string {
  return s
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t");
}

// --- Generate scenario TOML files ---

/** Check if any step in any turn has tool calls. */
function turnsHaveToolCalls(turns: ConversationTurn[]): boolean {
  return turns.some((t) => t.steps.some((s) => s.toolCalls.length > 0));
}

/**
 * Emit a ResponseStep as TOML lines.
 * `prefix` is the full TOML section prefix (e.g., "responses.response").
 * `shortKey` is the simple key within the current table context (e.g., "response").
 */
/**
 * Transform a raw JSONL tool result into the display-format string that
 * claudeless uses for rendering. Each tool type has its own display format:
 * - Write: "Wrote N lines to {file_path}"
 * - Read: "N file" (or "N file (M lines)" for multi-line content)
 */
function formatToolResultForDisplay(tc: ExtractedToolCall): string | null {
  if (tc.result === null) return null;

  // Context reads from fixtures already have the display format
  if (tc.isContextRead) return tc.result;

  switch (tc.toolName) {
    case "Write": {
      const filePath = tc.input.file_path || "unknown";
      const content = tc.input.content || "";
      const lineCount = content.split("\n").length;
      return `Wrote ${lineCount} lines to ${filePath}`;
    }
    case "Read": {
      // Read results show "N file" or "N file (M lines)" in the display
      return "1 file";
    }
    default:
      return tc.result;
  }
}

function emitResponseStep(lines: string[], prefix: string, shortKey: string, step: ResponseStep): void {
  if (step.toolCalls.length === 0) {
    lines.push(`${shortKey} = "${tomlEscape(step.text)}"`);
    return;
  }

  // Detailed response with tool calls
  lines.push(`[${prefix}]`);
  lines.push(`text = "${tomlEscape(step.text)}"`);
  lines.push("");

  for (const tc of step.toolCalls) {
    const displayResult = formatToolResultForDisplay(tc);

    lines.push(`[[${prefix}.tool_calls]]`);
    lines.push(`tool = "${tc.toolName}"`);
    if (displayResult !== null) {
      lines.push(`result = "${tomlEscape(displayResult)}"`);
    }
    lines.push("");

    lines.push(`[${prefix}.tool_calls.input]`);
    for (const [key, value] of Object.entries(tc.input)) {
      lines.push(`${key} = ${tomlValue(value)}`);
    }
    lines.push("");
  }
}

/** Serialize a JS value as a TOML value. */
function tomlValue(value: any): string {
  if (typeof value === "string") return `"${tomlEscape(value)}"`;
  if (typeof value === "number") return String(value);
  if (typeof value === "boolean") return value ? "true" : "false";
  if (value === null || value === undefined) return '""';
  if (Array.isArray(value)) {
    const items = value.map((v) => tomlValue(v));
    return `[${items.join(", ")}]`;
  }
  if (typeof value === "object") {
    const pairs = Object.entries(value).map(([k, v]) => `${k} = ${tomlValue(v)}`);
    return `{ ${pairs.join(", ")} }`;
  }
  return `"${tomlEscape(String(value))}"`;
}

function generateScenario(
  scriptName: string,
  headers: ScriptHeaders,
  version: string,
  manifest: CapshManifest | null,
  fixturesDir: string,
  turns?: ConversationTurn[],
): string {
  const lines: string[] = [];

  lines.push(`name = "${scriptName}"`);
  lines.push("");

  // Deterministic identity
  lines.push('session_id = "00000000-0000-0000-0000-000000000001"');
  lines.push('project_path = "/test/project"');
  lines.push('launch_timestamp = "2025-01-01T00:00:00Z"');
  lines.push('user_name = "TestUser"');

  const versionNum = version.replace(/^v/, "");
  lines.push(`claude_version = "${versionNum}"`);
  lines.push('provider = "Claude API"');

  if (headers.args === "") {
    lines.push('default_model = "claude-sonnet-4-5-20250514"');
  }

  // Extract placeholder from first snapshot fixture
  if (manifest && manifest.snapshots.length > 0) {
    for (const snap of manifest.snapshots) {
      const placeholder = extractPlaceholder(fixturesDir, snap);
      if (placeholder) {
        lines.push(`placeholder = '${placeholder}'`);
        break;
      }
    }
  }

  lines.push("");

  // Trust setting based on config mode
  if (headers.config === "trusted") {
    lines.push("trusted = true");
  } else if (headers.config === "auth-only") {
    lines.push("trusted = false");
  } else if (headers.config === "welcome-back") {
    lines.push("trusted = true");
  }
  // empty config = no trust setting (triggers full onboarding)

  // Special fields from config mode
  if (headers.config === "empty") {
    lines.push("logged_in = false");
  }

  // Detect welcome-back from config header OR TUI fixture content
  let hasWelcomeBack = headers.config === "welcome-back";
  let rightPanel: string[] | null = null;

  if (manifest && manifest.snapshots.length > 0) {
    for (const snap of manifest.snapshots) {
      const panel = extractWelcomeBackRightPanel(fixturesDir, snap);
      if (panel) {
        hasWelcomeBack = true;
        rightPanel = panel;
        break;
      }
    }
  }

  if (hasWelcomeBack) {
    lines.push("show_welcome_back = true");
    if (rightPanel) {
      lines.push("welcome_back_right_panel = [");
      for (const row of rightPanel) {
        lines.push(`    "${tomlEscape(row)}",`);
      }
      lines.push("]");
    }
  }

  lines.push("");

  // Detect context reads from fixtures (auto-executed reads not in JSONL)
  const contextReads = turns ? detectContextReadsFromFixtures(fixturesDir, manifest, turns) : new Map();

  // Inject context reads into turns
  if (turns) {
    for (const [turnIdx, readResult] of contextReads) {
      const step = turns[turnIdx].steps[0];
      if (step) {
        // Prepend a Read tool call before existing tool calls
        step.toolCalls.unshift({
          toolName: "Read",
          toolUseId: "context_read",
          input: { file_path: "context" },
          result: readResult,
          isError: false,
          isContextRead: true,
        });
      }
    }
  }

  // Emit [[responses]] from extracted conversation turns
  if (turns && turns.length > 0) {
    for (const turn of turns) {
      const patternText = turn.prompt.length > 80
        ? turn.prompt.slice(0, 80)
        : turn.prompt;

      const hasToolCalls = turn.steps.some((s) => s.toolCalls.length > 0);

      lines.push("[[responses]]");
      lines.push(`pattern = { type = "contains", text = "${tomlEscape(patternText)}" }`);

      if (!hasToolCalls) {
        // Simple case: just text response
        const allText = turn.steps.map((s) => s.text).filter(Boolean).join("\n");
        lines.push(`response = "${tomlEscape(allText)}"`);
      } else if (turn.steps.length === 1) {
        // Single step with tool calls
        lines.push("");
        emitResponseStep(lines, "responses.response", "response", turn.steps[0]);
      } else {
        // Multi-step: first step is the response, rest are turns
        lines.push("");
        emitResponseStep(lines, "responses.response", "response", turn.steps[0]);

        for (let i = 1; i < turn.steps.length; i++) {
          const step = turn.steps[i];
          if (!step.text && step.toolCalls.length === 0) continue;

          lines.push("[[responses.turns]]");
          lines.push('expect = { type = "any" }');
          lines.push("");
          emitResponseStep(lines, "responses.turns.response", "response", step);
        }
      }

      lines.push("");
    }
  }

  // Default catch-all response
  lines.push('[default_response]');
  lines.push('text = "I understand. Let me help with that."');

  // Tool execution mode
  if (turns && turnsHaveToolCalls(turns)) {
    lines.push("");
    lines.push("[tool_execution]");
    lines.push('mode = "mock"');
  }

  return lines.join("\n") + "\n";
}

// --- Generate Rust test files ---

function toRustIdent(name: string): string {
  return name.replace(/-/g, "_").replace(/\./g, "_");
}

function generateCapshSpecs(
  version: string,
  manifests: CapshManifest[],
  manifestArgs: Map<string, string>,
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const manifest of manifests) {
    const fnName = `capsh_${toRustIdent(manifest.script)}`;
    const snapshots = manifest.snapshots
      .map((s) => `"${s}"`)
      .join(", ");

    const argsStr = manifestArgs.get(manifest.script) || "";
    const extraArgs = argsStr
      ? argsStr.split(/\s+/).filter(Boolean).map((a) => `"${a}"`).join(", ")
      : "";

    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_capsh_spec("${version}", "${manifest.script}", &[${snapshots}], &[${extraArgs}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface TmuxFixture {
  script: string;
  snapshot: string;
}

function generateTmuxSpecs(
  version: string,
  fixtures: TmuxFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `tmux_${toRustIdent(fixture.script)}`;
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_tmux_spec("${version}", "${fixture.script}", &["${fixture.snapshot}"]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface CliFixture {
  name: string;
  args: string[];
}

function generateCliSpecs(
  version: string,
  fixtures: CliFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `cli_${toRustIdent(fixture.name)}`;
    const args = fixture.args.map((a) => `"${a}"`).join(", ");
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::assert_cli_starts_with("${version}", "${fixture.name}", &[${args}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// --- Main ---

const version = process.argv[2] || detectLatestVersion();
const fixturesDir = path.join(FIXTURES_BASE, version);

if (!fs.existsSync(fixturesDir)) {
  process.stderr.write(`Error: Fixtures directory not found: ${fixturesDir}\n`);
  process.exit(1);
}

console.log(`Generating specs for ${version}...`);

// Ensure output directories exist
fs.mkdirSync(path.join(SPECS_DIR, "capsh"), { recursive: true });
fs.mkdirSync(path.join(SPECS_DIR, "scenarios"), { recursive: true });
fs.mkdirSync(path.join(RUST_TESTS_DIR, "specs"), { recursive: true });

// --- 1. Discover capsh manifests ---

const manifests: CapshManifest[] = [];
const manifestFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".manifest.json"))
  .sort();

for (const f of manifestFiles) {
  const content = fs.readFileSync(path.join(fixturesDir, f), "utf-8");
  const manifest: CapshManifest = JSON.parse(content);
  manifests.push(manifest);
}

console.log(`Found ${manifests.length} capsh manifests`);

// --- 2. Generate simplified capsh scripts + scenarios ---

const capshSourceDir = path.join(CAPTURE_DIR, "capsh");
let generatedCapsh = 0;
const manifestArgs = new Map<string, string>();

for (const manifest of manifests) {
  const scriptName = manifest.script;
  const sourceScript = path.join(capshSourceDir, `${scriptName}.capsh`);

  if (!fs.existsSync(sourceScript)) {
    console.warn(`  Warning: Source script not found: ${scriptName}.capsh`);
    continue;
  }

  const originalContent = fs.readFileSync(sourceScript, "utf-8");
  const headers = parseHeaders(originalContent);

  manifestArgs.set(scriptName, headers.args);

  // Generate simplified capsh script
  const simplified = simplifyCapshScript(originalContent);
  fs.writeFileSync(
    path.join(SPECS_DIR, "capsh", `${scriptName}.capsh`),
    simplified,
  );

  // Extract conversation turns from session JSONL
  const turns = extractConversationTurns(fixturesDir, scriptName);

  // Generate scenario TOML
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${scriptName}.toml`);
  const scenario = generateScenario(scriptName, headers, version, manifest, fixturesDir, turns);
  fs.writeFileSync(scenarioPath, scenario);

  generatedCapsh++;
}

console.log(`Generated ${generatedCapsh} simplified capsh scripts + scenarios`);

// --- 3. Discover tmux fixtures ---

const tmuxFixtures: TmuxFixture[] = [];
const tmuxFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".tmux.txt"))
  .sort();

for (const f of tmuxFiles) {
  const snapshot = path.basename(f, ".tmux.txt");
  const script = snapshot.replace(/_/g, "-");
  tmuxFixtures.push({ script, snapshot });

  // Generate a scenario for tmux specs too
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${script}.toml`);
  if (!fs.existsSync(scenarioPath)) {
    const scenario = generateScenario(script, { args: "--model haiku", config: "trusted", timeout: null }, version, null, fixturesDir);
    fs.writeFileSync(scenarioPath, scenario);
  }
}

console.log(`Found ${tmuxFixtures.length} tmux fixtures`);

// --- 4. Discover CLI fixtures ---

const cliFixtures: CliFixture[] = [];
const cliSourceDir = path.join(CAPTURE_DIR, "cli");
const cliFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".cli.txt"))
  .sort();

for (const f of cliFiles) {
  const name = path.basename(f, ".cli.txt");
  const cliScript = path.join(cliSourceDir, `${name}.cli`);

  let args: string[] = [];
  if (fs.existsSync(cliScript)) {
    const content = fs.readFileSync(cliScript, "utf-8");
    args = content
      .split("\n")
      .filter((l) => l.trim() && !l.startsWith("#"))
      .join(" ")
      .trim()
      .split(/\s+/);
  } else {
    if (name === "version") args = ["--version"];
    else if (name === "help") args = ["--help"];
    else args = [name, "--help"];
  }

  cliFixtures.push({ name, args });
}

console.log(`Found ${cliFixtures.length} CLI fixtures`);

// --- 5. Generate Rust test files ---

const capshRust = generateCapshSpecs(version, manifests, manifestArgs);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "capsh_specs.rs"), capshRust);
console.log(`Generated capsh_specs.rs (${manifests.length} tests)`);

const tmuxRust = generateTmuxSpecs(version, tmuxFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "tmux_specs.rs"), tmuxRust);
console.log(`Generated tmux_specs.rs (${tmuxFixtures.length} tests)`);

const cliRust = generateCliSpecs(version, cliFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "cli_specs.rs"), cliRust);
console.log(`Generated cli_specs.rs (${cliFixtures.length} tests)`);

// --- Summary ---

const total = manifests.length + tmuxFixtures.length + cliFixtures.length;
console.log(`\nTotal: ${total} test functions generated`);
console.log(`  capsh: ${manifests.length}`);
console.log(`  tmux:  ${tmuxFixtures.length}`);
console.log(`  cli:   ${cliFixtures.length}`);
