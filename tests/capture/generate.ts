#!/usr/bin/env bun
// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC

//! Generate spec test files from capture fixtures.
//!
//! Reads:
//!   - tests/fixtures/v{VERSION}/*.manifest.json  (capsh script manifests)
//!   - tests/fixtures/v{VERSION}/*.cli.txt        (CLI output fixtures)
//!   - tests/fixtures/v{VERSION}/*.tmux.txt       (tmux fixtures)
//!   - tests/capture/capsh/*.capsh                (original capsh scripts)
//!   - tests/capture/cli/*.cli                    (CLI scripts)
//!   - tests/capture/tmux/*.sh                    (tmux scripts)
//!
//! Writes:
//!   - tests/specs/capsh/*.capsh                  (simplified capsh scripts)
//!   - tests/specs/scenarios/*.toml               (scenario files)
//!   - crates/cli/tests/capsh_specs.rs            (generated Rust tests)
//!   - crates/cli/tests/tmux_specs.rs             (generated Rust tests)
//!   - crates/cli/tests/cli_specs.rs              (generated Rust tests)

import * as fs from "node:fs";
import * as path from "node:path";

const SCRIPT_DIR = path.dirname(new URL(import.meta.url).pathname);
const ROOT = path.resolve(SCRIPT_DIR, "../..");
const FIXTURES_BASE = path.join(ROOT, "tests/fixtures");
const CAPTURE_DIR = path.join(ROOT, "tests/capture");
const SPECS_DIR = path.join(ROOT, "tests/specs");
const RUST_TESTS_DIR = path.join(ROOT, "crates/cli/tests");

const LICENSE_HEADER = `// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC`;

const GENERATED_HEADER = `// AUTO-GENERATED by tests/capture/generate.ts — do not edit manually`;

// --- Detect latest fixture version ---

function detectLatestVersion(): string {
  const entries = fs
    .readdirSync(FIXTURES_BASE)
    .filter((e) => e.startsWith("v") && fs.statSync(path.join(FIXTURES_BASE, e)).isDirectory())
    .sort();
  if (entries.length === 0) {
    throw new Error("No fixture versions found in tests/fixtures/");
  }
  return entries[entries.length - 1];
}

// --- Parse capsh script headers ---

interface ScriptHeaders {
  args: string; // CLI args (empty string = default --model haiku)
  config: "trusted" | "welcome-back" | "auth-only" | "empty";
  timeout: number | null;
}

function parseHeaders(content: string): ScriptHeaders {
  const argsMatch = content.match(/^# Args:\s*(.*)$/m);
  let args = "--model haiku"; // default
  if (argsMatch) {
    const val = argsMatch[1].trim();
    if (val === "(none)" || val === "none") args = "";
    else args = val;
  }

  const configMatch = content.match(/^# Config:\s*(.*)$/m);
  let config: ScriptHeaders["config"] = "trusted";
  if (configMatch) {
    const val = configMatch[1].trim().split(/\s+/)[0];
    if (val === "welcome-back" || val === "auth-only" || val === "empty") {
      config = val;
    }
  }

  const timeoutMatch = content.match(/^# Timeout:\s*(\d+)/m);
  const timeout = timeoutMatch ? Number(timeoutMatch[1]) : null;

  return { args, config, timeout };
}

// --- Simplify capsh scripts ---

/**
 * Parse a duration string from capsh and return milliseconds.
 * Examples: "500" -> 500, "3s" -> 3000, "10s" -> 10000, "2m" -> 120000
 */
function parseDuration(s: string): number {
  if (s.endsWith("m")) return Number(s.slice(0, -1)) * 60000;
  if (s.endsWith("s")) return Number(s.slice(0, -1)) * 1000;
  if (s.endsWith("ms")) return Number(s.slice(0, -2));
  return Number(s);
}

/**
 * Format a duration in milliseconds as a capsh duration string.
 * Uses the most compact representation.
 */
function formatDuration(ms: number): string {
  if (ms >= 1000 && ms % 1000 === 0) return `${ms / 1000}s`;
  return `${ms}`;
}

/**
 * Clamp a wait-for-pattern timeout to max 5s (needs time for app startup + render).
 * Clamp a bare wait (duration) to max 500ms.
 * Clamp inline delays to max 100ms.
 */
function simplifyCapshScript(content: string): string {
  const lines = content.split("\n");
  const output: string[] = [];
  let inConditional = false;
  let inElse = false;
  let inMatch = false;
  let matchTimeout: string | null = null;
  let matchFirstArm: { pattern: string; command: string } | null = null;
  let conditionalDepth = 0;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments (keep header comments)
    if (trimmed === "" || trimmed.startsWith("#")) {
      output.push(line);
      continue;
    }

    // Handle if/else/end blocks — strip conditionals, keep the else branch
    // (the else branch is the "normal" path when claudeless is used, since
    // claudeless doesn't show trust dialogs by default)
    if (trimmed.startsWith("if wait")) {
      inConditional = true;
      inElse = false;
      conditionalDepth++;
      continue;
    }
    if (trimmed === "else" && inConditional) {
      inElse = true;
      continue;
    }
    if (trimmed === "end" && inConditional) {
      conditionalDepth--;
      if (conditionalDepth === 0) {
        inConditional = false;
        inElse = false;
      }
      continue;
    }
    if (inConditional && !inElse) {
      // Skip the if-branch
      continue;
    }
    if (inConditional && inElse) {
      // Keep the else-branch content (will be processed below)
      // Fall through to normal processing
    }

    // Handle match/end blocks — extract first arm's wait pattern + command
    if (trimmed.startsWith("match ")) {
      inMatch = true;
      matchTimeout = trimmed.match(/^match\s+(\d+(?:ms|s|m)?)$/)?.[1] || null;
      matchFirstArm = null;
      continue;
    }
    if (trimmed === "end" && inMatch) {
      inMatch = false;
      // Emit the first arm: wait for the pattern, then run the command
      if (matchFirstArm) {
        const waitTimeout = matchTimeout ? ` ${formatDuration(Math.min(parseDuration(matchTimeout), 5000))}` : " 5s";
        output.push(`wait "${matchFirstArm.pattern}"${waitTimeout}`);
        output.push(matchFirstArm.command);
      }
      matchTimeout = null;
      matchFirstArm = null;
      continue;
    }
    if (inMatch) {
      // Inside match block — capture the first arm's pattern and command
      const armMatch = trimmed.match(/^"([^"]*)"\s*->\s*(.+)$/);
      if (armMatch && !matchFirstArm) {
        matchFirstArm = { pattern: armMatch[1], command: armMatch[2] };
      }
      continue;
    }

    // Process wait commands
    if (trimmed.startsWith("wait ")) {
      const processed = simplifyWait(trimmed);
      output.push(processed);
      continue;
    }

    // Process bare thinking spinner wait pairs: wrap in conditional
    // Detect "wait \w+…" followed by "wait !\w+…" and wrap in if/end
    // (claudeless responds instantly, no spinner appears)
    // This is handled as a post-processing step below

    // Process send commands — clamp inline delays
    if (trimmed.startsWith("send ")) {
      const processed = simplifySend(trimmed);
      output.push(processed);
      continue;
    }

    // Keep everything else as-is (snapshot, kill)
    output.push(trimmed);
  }

  // Post-process: wrap bare thinking spinner wait pairs in if/end blocks.
  // Pattern: `wait "\w+…" Ns` followed by `wait !"\w+…" Ms` → `if wait "\w+…" Ns\n    wait !"\w+…" Ms\nend`
  // This makes the spinner wait conditional (claudeless responds instantly, no spinner).
  const final_output: string[] = [];
  for (let i = 0; i < output.length; i++) {
    const cur = output[i].trim();
    const next = i + 1 < output.length ? output[i + 1].trim() : "";

    if (cur.match(/^wait\s+"[^"]*…"/) && next.match(/^wait\s+!"[^"]*…"/)) {
      final_output.push(`if ${cur}`);
      final_output.push(`    ${next}`);
      final_output.push("end");
      i++; // skip next line (already consumed)
      continue;
    }
    final_output.push(output[i]);
  }

  return final_output.join("\n");
}

/**
 * Simplify a wait command:
 * - `wait "pattern" 30s` → `wait "pattern" 5s`  (pattern waits need time for startup)
 * - `wait !"pattern" 10s` → `wait !"pattern" 5s`
 * - `wait 2s` → `wait 500`                       (bare delays just need to be short)
 * - `wait 100` → `wait 100` (already short)
 */
function simplifyWait(line: string): string {
  const trimmed = line.trim();

  // Bare wait with duration: `wait 500`, `wait 2s`
  const bareWaitMatch = trimmed.match(/^wait\s+(\d+(?:ms|s|m)?)$/);
  if (bareWaitMatch) {
    const ms = parseDuration(bareWaitMatch[1]);
    const clamped = Math.min(ms, 500);
    return `wait ${formatDuration(clamped)}`;
  }

  // Pattern wait: `wait "pattern" 10s` or `wait !"pattern" 10s`
  const patternWaitMatch = trimmed.match(/^(wait\s+!?"[^"]*")\s+(\d+(?:ms|s|m)?)$/);
  if (patternWaitMatch) {
    const prefix = patternWaitMatch[1];
    const ms = parseDuration(patternWaitMatch[2]);
    const clamped = Math.min(ms, 5000);
    return `${prefix} ${formatDuration(clamped)}`;
  }

  // Pattern wait without timeout: `wait "pattern"` — add a reasonable timeout
  const patternOnlyMatch = trimmed.match(/^wait\s+!?"[^"]*"$/);
  if (patternOnlyMatch) {
    return `${trimmed} 5s`;
  }

  return trimmed;
}

/**
 * Simplify a send command — clamp inline delays to 100ms.
 * `send "/help" 100 <Enter>` → `send "/help" 100 <Enter>` (already ≤100)
 * `send <C-u> 200 "/exit" 200 <Enter>` → `send <C-u> 100 "/exit" 100 <Enter>`
 */
function simplifySend(line: string): string {
  // Replace numeric tokens that are standalone delays (between quoted strings or key specials)
  return line.replace(/\s(\d+)\s/g, (match, num) => {
    const ms = Number(num);
    if (ms > 100) return ` 100 `;
    return match;
  });
}

// --- Extract placeholder text from fixture files ---

/**
 * Extract the placeholder text from a TUI fixture file.
 * Looks for `❯\xa0Try "..."` or `!\xa0Try "..."` patterns.
 */
function extractPlaceholder(fixturesDir: string, snapshotName: string): string | null {
  const fixturePath = path.join(fixturesDir, `${snapshotName}.tui.txt`);
  if (!fs.existsSync(fixturePath)) return null;

  const content = fs.readFileSync(fixturePath, "utf-8");
  // Match ❯ or ! followed by NBSP or space, then the placeholder text
  const match = content.match(/[❯!][\s\u00A0](Try "[^"]*")/);
  return match ? match[1] : null;
}

/**
 * Extract the welcome-back right panel rows from a TUI fixture file.
 * The right panel is inside the welcome box, after the │ separator.
 */
function extractWelcomeBackRightPanel(fixturesDir: string, snapshotName: string): string[] | null {
  const fixturePath = path.join(fixturesDir, `${snapshotName}.tui.txt`);
  if (!fs.existsSync(fixturePath)) return null;

  const content = fs.readFileSync(fixturePath, "utf-8");
  if (!content.includes("Welcome back!")) return null;

  const lines = content.split("\n");
  const rows: string[] = [];

  for (const line of lines) {
    // Match lines inside the welcome box with a right panel
    // Format: │ ... │ Right panel text     │
    const boxMatch = line.match(/^│.*│\s(.{23,25})\s*│$/);
    if (!boxMatch) continue;

    const rightText = boxMatch[1].trimEnd();

    if (rightText.match(/^\s*$/)) {
      rows.push("");
      continue;
    }

    if (rightText.match(/^─+$/)) {
      rows.push("---");
      continue;
    }

    rows.push(rightText.trim());
  }

  if (rows.length === 0) return null;

  // Trim trailing empty rows
  while (rows.length > 0 && rows[rows.length - 1] === "") {
    rows.pop();
  }

  return rows.length > 0 ? rows : null;
}

// --- Extract conversation turns from session JSONL files ---

interface ExtractedToolCall {
  toolName: string;
  toolUseId: string;
  input: Record<string, any>;
  result: string | null;
  isError: boolean;
  /** True if this is a synthetic context read injected from fixture, not from JSONL. */
  isContextRead?: boolean;
}

interface ResponseStep {
  text: string;
  toolCalls: ExtractedToolCall[];
}

interface ConversationTurn {
  prompt: string;
  steps: ResponseStep[];
  timestamp: string;
}

interface JsonlEntry {
  type: string;
  uuid?: string;
  parentUuid?: string | null;
  userType?: string;
  isMeta?: boolean;
  isApiErrorMessage?: boolean;
  isSidechain?: boolean;
  cwd?: string;
  message?: {
    role: string;
    content: string | Array<{ type: string; text?: string; name?: string; id?: string; input?: any; tool_use_id?: string; content?: string; is_error?: boolean; thinking?: string }>;
  };
  timestamp?: string;
  toolUseResult?: any;
}

/** Check if a user message contains tool_result blocks (not a real user prompt). */
function isToolResultMessage(entry: JsonlEntry): boolean {
  if (entry.type !== "user") return false;
  const content = entry.message?.content;
  if (!Array.isArray(content)) return false;
  return content.some((b) => b.type === "tool_result");
}

/**
 * Attempt to salvage uuid/parentUuid/type from a malformed JSONL line.
 * Some lines have broken JSON in thinking content. We extract the key fields
 * so the chain-building logic can still connect parent→child relationships.
 */
function salvageMalformedEntry(line: string): JsonlEntry | null {
  const uuidMatch = line.match(/"uuid"\s*:\s*"([^"]+)"/);
  const parentMatch = line.match(/"parentUuid"\s*:\s*"([^"]+)"/);
  const typeMatch = line.match(/"type"\s*:\s*"(user|assistant|progress|file-history-snapshot)"/);

  if (!uuidMatch || !typeMatch) return null;

  return {
    type: typeMatch[1],
    uuid: uuidMatch[1],
    parentUuid: parentMatch ? parentMatch[1] : null,
    timestamp: (line.match(/"timestamp"\s*:\s*"([^"]+)"/) || [])[1],
  };
}

/**
 * Extract a likely filename from user prompt text.
 * Matches patterns like "file called X", "file named X", "the file X",
 * "Read the file X", etc.
 */
function extractFilenameFromPrompt(prompt: string): string | null {
  // Match "file called/named X" or "file X.ext"
  const patterns = [
    /file\s+called\s+(\S+)/i,
    /file\s+named\s+(\S+)/i,
    /(?:Read|read|Write|write|Edit|edit|Create|create)\s+(?:a\s+)?(?:new\s+)?(?:file\s+)?(?:called\s+)?(\S*\.[\w-]+)/i,
    /the\s+file\s+(\S*\.[\w-]+)/i,
  ];
  for (const pattern of patterns) {
    const match = prompt.match(pattern);
    if (match) return match[1];
  }
  return null;
}

/**
 * Normalize a file path from JSONL tool inputs.
 * Strips the capture workspace cwd prefix to make paths relative.
 * If file_path equals cwd exactly (model gave directory as path), tries to
 * find the actual filename from file-history-snapshots or the user prompt.
 */
function normalizeFilePath(filePath: string, cwd: string | null, fileHistoryNames: string[], promptText: string | null): string {
  if (!cwd) return filePath;

  // Strip cwd prefix + "/" to get relative path
  const cwdWithSlash = cwd.endsWith("/") ? cwd : cwd + "/";
  if (filePath.startsWith(cwdWithSlash)) {
    return filePath.slice(cwdWithSlash.length);
  }

  // file_path equals cwd exactly — model gave directory as file path
  if (filePath === cwd) {
    // Try to find the actual filename from file-history-snapshots
    if (fileHistoryNames.length > 0) {
      return fileHistoryNames[fileHistoryNames.length - 1];
    }
    // Try to extract from user prompt
    if (promptText) {
      const extracted = extractFilenameFromPrompt(promptText);
      if (extracted) return extracted;
    }
    // Can't determine — return as-is
    return filePath;
  }

  return filePath;
}

/**
 * Normalize file_path values in tool call inputs.
 */
function normalizeToolInput(input: Record<string, any>, cwd: string | null, fileHistoryNames: string[], promptText: string | null): Record<string, any> {
  const result = { ...input };
  if (typeof result.file_path === "string") {
    result.file_path = normalizeFilePath(result.file_path, cwd, fileHistoryNames, promptText);
  }
  return result;
}

/** Strip <system-reminder>...</system-reminder> tags from tool result text. */
function stripSystemReminders(text: string): string {
  return text.replace(/<system-reminder>[\s\S]*?<\/system-reminder>/g, "").trim();
}

/** Strip markdown code fences from response text (```...```). */
function stripCodeFences(text: string): string {
  // Remove wrapping code fences: ```\ncontent\n```  →  content
  let result = text.replace(/^```\w*\n([\s\S]*?)\n```$/g, "$1").trim();
  // Strip Read tool arrow prefixes (→) from lines
  result = result.replace(/^→/gm, "");
  return result;
}

/**
 * Strip Read tool line-number prefixes from tool result text.
 * Read results come formatted as "     1→content\n     2→more\n".
 * Strip the "     N→" prefix from each line to get the raw file content.
 */
function stripReadLineNumbers(text: string): string {
  return text.replace(/^ *\d+\u2192/gm, "");
}

/**
 * Extract user→assistant conversation turns from session JSONL files.
 * Reads all .jsonl files from {fixturesDir}/{scriptName}.projects/,
 * skipping subagents/, meta messages, errors, commands, and interrupts.
 *
 * Extracts full tool-use chains as ResponseStep[] from JSONL data.
 */
function extractConversationTurns(fixturesDir: string, scriptName: string): ConversationTurn[] {
  const projectsDir = path.join(fixturesDir, `${scriptName}.projects`);
  if (!fs.existsSync(projectsDir)) return [];

  // Find all session JSONL files (skip subagents/)
  const jsonlFiles: string[] = [];
  for (const projDir of fs.readdirSync(projectsDir)) {
    const projPath = path.join(projectsDir, projDir);
    if (!fs.statSync(projPath).isDirectory()) continue;
    for (const file of fs.readdirSync(projPath)) {
      if (file.endsWith(".jsonl")) {
        const fullPath = path.join(projPath, file);
        if (!fullPath.includes("/subagents/")) {
          jsonlFiles.push(fullPath);
        }
      }
    }
  }

  const allTurns: ConversationTurn[] = [];

  for (const file of jsonlFiles) {
    const content = fs.readFileSync(file, "utf-8");
    const lines = content.split("\n").filter((l) => l.trim());

    // Parse all entries
    const entries: JsonlEntry[] = [];
    for (const line of lines) {
      try {
        const entry: JsonlEntry = JSON.parse(line);
        entries.push(entry);
      } catch {
        // Some JSONL lines have malformed thinking content with unescaped quotes.
        // Salvage uuid/parentUuid/type so chain-building still works.
        const salvaged = salvageMalformedEntry(line);
        if (salvaged) entries.push(salvaged);
      }
    }

    // Build uuid→entry map and extract cwd
    const byUuid = new Map<string, JsonlEntry>();
    let sessionCwd: string | null = null;
    for (const entry of entries) {
      if (entry.uuid) {
        byUuid.set(entry.uuid, entry);
      }
      if (entry.cwd && !sessionCwd) {
        sessionCwd = entry.cwd;
      }
    }

    // First pass: identify prompt user messages (real user input, not tool results)
    const promptUuids: string[] = [];
    for (const entry of entries) {
      if (entry.type !== "user" || !entry.uuid) continue;
      if (entry.isMeta) continue;
      if (entry.isSidechain) continue;
      if (entry.userType && entry.userType !== "external") continue;
      if (isToolResultMessage(entry)) continue;

      const text = extractMessageText(entry.message?.content);
      if (!text) continue;

      // Skip command messages
      if (text.includes("<command-name>") || text.includes("<local-command-caveat>") || text.includes("<local-command-stdout>")) continue;
      // Skip interrupted messages
      if (text.includes("[Request interrupted by user")) continue;
      // Skip compact summaries
      if ((entry as any).isCompactSummary) continue;
      // Skip visible-in-transcript-only messages
      if ((entry as any).isVisibleInTranscriptOnly) continue;

      promptUuids.push(entry.uuid);
    }

    // Second pass: for each prompt, build forward chain and extract steps
    for (const promptUuid of promptUuids) {
      const promptEntry = byUuid.get(promptUuid)!;
      const promptText = extractMessageText(promptEntry.message?.content);
      if (!promptText) continue;

      // Build forward chain: all uuids reachable from promptUuid via parentUuid
      const chainUuids = new Set<string>([promptUuid]);
      for (const entry of entries) {
        if (!entry.uuid) continue;
        if (entry.parentUuid && chainUuids.has(entry.parentUuid)) {
          chainUuids.add(entry.uuid);
        }
      }

      // Collect chain entries in order (excluding the prompt itself)
      const chainEntries = entries.filter(
        (e) => e.uuid && chainUuids.has(e.uuid) && e.uuid !== promptUuid
      );

      // Collect file-history-snapshot filenames from ALL entries for path resolution.
      // File-history-snapshots don't have uuid/parentUuid, so they're not in the chain.
      const fileHistoryNames: string[] = [];
      for (const entry of entries) {
        if (entry.type === "file-history-snapshot") {
          const snapshot = (entry as any).snapshot;
          if (snapshot?.trackedFileBackups) {
            for (const name of Object.keys(snapshot.trackedFileBackups)) {
              if (!fileHistoryNames.includes(name)) {
                fileHistoryNames.push(name);
              }
            }
          }
        }
      }

      // Walk chain to build ResponseStep[]
      const steps: ResponseStep[] = [];
      let currentStep: ResponseStep = { text: "", toolCalls: [] };
      const toolCallsById = new Map<string, ExtractedToolCall>();

      for (const entry of chainEntries) {
        if (entry.type === "file-history-snapshot" || entry.type === "progress") continue;
        if (entry.isSidechain) continue;
        if (entry.isMeta) continue;
        if (entry.isApiErrorMessage) continue;

        if (entry.type === "assistant" && entry.message?.content) {
          const content = entry.message.content;
          if (typeof content === "string") {
            if (currentStep.text) currentStep.text += "\n";
            currentStep.text += content;
            continue;
          }
          if (Array.isArray(content)) {
            for (const block of content) {
              if (block.type === "thinking") continue;
              if (block.type === "text" && block.text) {
                if (currentStep.text) currentStep.text += "\n";
                currentStep.text += block.text;
              }
              if (block.type === "tool_use" && block.name && block.id) {
                const tc: ExtractedToolCall = {
                  toolName: block.name,
                  toolUseId: block.id,
                  input: normalizeToolInput(block.input || {}, sessionCwd, fileHistoryNames, promptText),
                  result: null,
                  isError: false,
                };
                currentStep.toolCalls.push(tc);
                toolCallsById.set(block.id, tc);
              }
            }
          }
        }

        if (entry.type === "user" && entry.message?.content) {
          const content = entry.message.content;

          // String content = real user prompt or meta message — stop chain
          if (typeof content === "string") {
            if (entry.isMeta) continue;
            if (content.includes("<command-name>") || content.includes("<local-command-caveat>") || content.includes("<local-command-stdout>")) continue;
            if (content.includes("[Request interrupted by user")) continue;
            // Real user prompt — new turn started, stop here
            break;
          }

          if (!Array.isArray(content)) continue;

          // Check for tool_result blocks
          const hasToolResult = content.some((b) => b.type === "tool_result");
          if (hasToolResult) {
            for (const block of content) {
              if (block.type === "tool_result" && block.tool_use_id) {
                const tc = toolCallsById.get(block.tool_use_id);
                if (tc) {
                  let resultText = block.content ? stripSystemReminders(block.content) : null;
                  if (resultText && tc.toolName === "Read") {
                    resultText = stripReadLineNumbers(resultText);
                  }
                  // Normalize cwd paths in result text
                  if (resultText && sessionCwd) {
                    resultText = resultText.replace(new RegExp(sessionCwd.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "/?", "g"), "");
                  }
                  tc.result = resultText;
                  tc.isError = block.is_error === true;
                }
              }
            }
            // Push current step and start new one (tool result triggers new API turn)
            steps.push(currentStep);
            currentStep = { text: "", toolCalls: [] };
            continue;
          }

          // Check for interrupt messages - skip them
          const text = extractMessageText(content);
          if (text && text.includes("[Request interrupted by user")) continue;
          // Skip command messages that appear in the chain
          if (text && (text.includes("<command-name>") || text.includes("<local-command-caveat>") || text.includes("<local-command-stdout>"))) continue;

          // If this is a real user prompt (not tool_result, not interrupt, not command),
          // it means a new conversation turn started — stop building steps for this prompt.
          if (text) break;
        }
      }

      // Push final step if non-empty
      if (currentStep.text || currentStep.toolCalls.length > 0) {
        steps.push(currentStep);
      }

      // Collapse: if the last step is text-only (no tool calls) and there are
      // earlier steps with tool calls, merge the text into the first step.
      // This matches how Claude responses render: tool calls + final text in one response.
      if (steps.length >= 2) {
        const lastStep = steps[steps.length - 1];
        if (lastStep.text && lastStep.toolCalls.length === 0) {
          steps[0].text = lastStep.text;
          steps.pop();
        }
      }

      // Strip markdown code fences from response text in steps with tool calls
      for (const step of steps) {
        if (step.toolCalls.length > 0 && step.text) {
          step.text = stripCodeFences(step.text);
        }
      }

      // Skip turns with no meaningful content
      if (steps.length === 0) continue;
      if (steps.every((s) => !s.text && s.toolCalls.length === 0)) continue;

      const cleaned = cleanPrompt(promptText);
      if (!cleaned) continue;

      allTurns.push({
        prompt: cleaned,
        steps,
        timestamp: promptEntry.timestamp || "",
      });
    }
  }

  // Deduplicate by prompt content (keep last occurrence from retries)
  const seen = new Map<string, ConversationTurn>();
  for (const turn of allTurns) {
    seen.set(turn.prompt, turn);
  }

  // Sort by timestamp to maintain conversation order
  const result = [...seen.values()];
  result.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

  return result;
}

/** Extract text from a user message content field (string or array). */
function extractMessageText(content: string | Array<{ type: string; text?: string }> | undefined): string | null {
  if (!content) return null;
  if (typeof content === "string") return content;
  if (Array.isArray(content)) {
    const texts = content
      .filter((b) => b.type === "text" && b.text)
      .map((b) => b.text!);
    return texts.length > 0 ? texts.join("\n") : null;
  }
  return null;
}

/**
 * Clean up a user prompt for pattern matching:
 * - Strip embedded slash commands (e.g., "\n/compact" at end of prompt)
 * - Strip control characters (e.g., Ctrl-U = \u0015)
 * - Trim whitespace
 */
function cleanPrompt(prompt: string): string {
  // Remove control characters (except newline)
  let cleaned = prompt.replace(/[\x00-\x09\x0B-\x1F\x7F]/g, "");

  // Split lines and remove lines that are slash commands
  const lines = cleaned.split("\n");
  const kept = lines.filter((line) => !line.trim().match(/^\/\w+/));
  cleaned = kept.join("\n").trim();

  return cleaned;
}

/** Escape a string for use in TOML double-quoted strings. */
function tomlEscape(s: string): string {
  return s
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t");
}

// --- Detect context reads from fixtures ---

/**
 * Scan fixture TUI snapshots for context reads ("Reading N file…" or "Read N file")
 * that appear before permission dialogs. These are Claude Code's internal context
 * gathering and are NOT logged as tool_use in the JSONL. Returns a map from
 * turn index to the context read result string to inject.
 */
function detectContextReadsFromFixtures(
  fixturesDir: string,
  manifest: CapshManifest | null,
  turns: ConversationTurn[],
): Map<number, string> {
  const contextReads = new Map<number, string>();
  if (!manifest) return contextReads;

  for (const snap of manifest.snapshots) {
    const fixturePath = path.join(fixturesDir, `${snap}.tui.txt`);
    if (!fs.existsSync(fixturePath)) continue;

    const content = fs.readFileSync(fixturePath, "utf-8");

    // Look for "⏺ Reading N file…" patterns (context reads in progress)
    const readingMatch = content.match(/⏺ Reading (\d+ file\S*)/);
    if (!readingMatch) continue;

    // Find which turn this context read belongs to by checking if the fixture
    // contains the prompt text for a turn that has tool calls but no Read
    for (let i = 0; i < turns.length; i++) {
      const turn = turns[i];
      const firstStep = turn.steps[0];
      if (!firstStep || firstStep.toolCalls.length === 0) continue;

      // Check if turn already has a Read tool call
      const hasRead = firstStep.toolCalls.some((tc) => tc.toolName === "Read");
      if (hasRead) continue;

      // Check if the fixture contains this turn's prompt
      if (content.includes(turn.prompt.slice(0, 40))) {
        // Inject context read result with trailing ellipsis for "Reading" display
        contextReads.set(i, readingMatch[1]);
        break;
      }
    }
  }

  return contextReads;
}

// --- Generate scenario TOML files ---

/** Check if any step in any turn has tool calls. */
function turnsHaveToolCalls(turns: ConversationTurn[]): boolean {
  return turns.some((t) => t.steps.some((s) => s.toolCalls.length > 0));
}

/**
 * Emit a ResponseStep as TOML lines.
 * `prefix` is the full TOML section prefix (e.g., "responses.response").
 * `shortKey` is the simple key within the current table context (e.g., "response").
 */
/**
 * Transform a raw JSONL tool result into the display-format string that
 * claudeless uses for rendering. Each tool type has its own display format:
 * - Write: "Wrote N lines to {file_path}"
 * - Read: "N file" (or "N file (M lines)" for multi-line content)
 */
function formatToolResultForDisplay(tc: ExtractedToolCall): string | null {
  if (tc.result === null) return null;

  // Context reads from fixtures already have the display format
  if (tc.isContextRead) return tc.result;

  switch (tc.toolName) {
    case "Write": {
      const filePath = tc.input.file_path || "unknown";
      const content = tc.input.content || "";
      const lineCount = content.split("\n").length;
      return `Wrote ${lineCount} lines to ${filePath}`;
    }
    case "Read": {
      // Read results show "N file" or "N file (M lines)" in the display
      return "1 file";
    }
    default:
      return tc.result;
  }
}

function emitResponseStep(lines: string[], prefix: string, shortKey: string, step: ResponseStep): void {
  if (step.toolCalls.length === 0) {
    lines.push(`${shortKey} = "${tomlEscape(step.text)}"`);
    return;
  }

  // Detailed response with tool calls
  lines.push(`[${prefix}]`);
  lines.push(`text = "${tomlEscape(step.text)}"`);
  lines.push("");

  for (const tc of step.toolCalls) {
    const displayResult = formatToolResultForDisplay(tc);

    lines.push(`[[${prefix}.tool_calls]]`);
    lines.push(`tool = "${tc.toolName}"`);
    if (displayResult !== null) {
      lines.push(`result = "${tomlEscape(displayResult)}"`);
    }
    lines.push("");

    lines.push(`[${prefix}.tool_calls.input]`);
    for (const [key, value] of Object.entries(tc.input)) {
      lines.push(`${key} = ${tomlValue(value)}`);
    }
    lines.push("");
  }
}

/** Serialize a JS value as a TOML value. */
function tomlValue(value: any): string {
  if (typeof value === "string") return `"${tomlEscape(value)}"`;
  if (typeof value === "number") return String(value);
  if (typeof value === "boolean") return value ? "true" : "false";
  if (value === null || value === undefined) return '""';
  if (Array.isArray(value)) {
    const items = value.map((v) => tomlValue(v));
    return `[${items.join(", ")}]`;
  }
  if (typeof value === "object") {
    const pairs = Object.entries(value).map(([k, v]) => `${k} = ${tomlValue(v)}`);
    return `{ ${pairs.join(", ")} }`;
  }
  return `"${tomlEscape(String(value))}"`;
}

function generateScenario(
  scriptName: string,
  headers: ScriptHeaders,
  version: string,
  manifest: CapshManifest | null,
  fixturesDir: string,
  turns?: ConversationTurn[],
): string {
  const lines: string[] = [];

  lines.push(`name = "${scriptName}"`);
  lines.push("");

  // Deterministic identity
  lines.push('session_id = "00000000-0000-0000-0000-000000000001"');
  lines.push('project_path = "/test/project"');
  lines.push('launch_timestamp = "2025-01-01T00:00:00Z"');
  lines.push('user_name = "TestUser"');

  const versionNum = version.replace(/^v/, "");
  lines.push(`claude_version = "${versionNum}"`);
  lines.push('provider = "Claude API"');

  if (headers.args === "") {
    lines.push('default_model = "claude-sonnet-4-5-20250514"');
  }

  // Extract placeholder from first snapshot fixture
  if (manifest && manifest.snapshots.length > 0) {
    for (const snap of manifest.snapshots) {
      const placeholder = extractPlaceholder(fixturesDir, snap);
      if (placeholder) {
        lines.push(`placeholder = '${placeholder}'`);
        break;
      }
    }
  }

  lines.push("");

  // Trust setting based on config mode
  if (headers.config === "trusted") {
    lines.push("trusted = true");
  } else if (headers.config === "auth-only") {
    lines.push("trusted = false");
  } else if (headers.config === "welcome-back") {
    lines.push("trusted = true");
  }
  // empty config = no trust setting (triggers full onboarding)

  // Special fields from config mode
  if (headers.config === "empty") {
    lines.push("logged_in = false");
  }

  // Detect welcome-back from config header OR TUI fixture content
  let hasWelcomeBack = headers.config === "welcome-back";
  let rightPanel: string[] | null = null;

  if (manifest && manifest.snapshots.length > 0) {
    for (const snap of manifest.snapshots) {
      const panel = extractWelcomeBackRightPanel(fixturesDir, snap);
      if (panel) {
        hasWelcomeBack = true;
        rightPanel = panel;
        break;
      }
    }
  }

  if (hasWelcomeBack) {
    lines.push("show_welcome_back = true");
    if (rightPanel) {
      lines.push("welcome_back_right_panel = [");
      for (const row of rightPanel) {
        lines.push(`    "${tomlEscape(row)}",`);
      }
      lines.push("]");
    }
  }

  lines.push("");

  // Detect context reads from fixtures (auto-executed reads not in JSONL)
  const contextReads = turns ? detectContextReadsFromFixtures(fixturesDir, manifest, turns) : new Map();

  // Inject context reads into turns
  if (turns) {
    for (const [turnIdx, readResult] of contextReads) {
      const step = turns[turnIdx].steps[0];
      if (step) {
        // Prepend a Read tool call before existing tool calls
        step.toolCalls.unshift({
          toolName: "Read",
          toolUseId: "context_read",
          input: { file_path: "context" },
          result: readResult,
          isError: false,
          isContextRead: true,
        });
      }
    }
  }

  // Emit [[responses]] from extracted conversation turns
  if (turns && turns.length > 0) {
    for (const turn of turns) {
      const patternText = turn.prompt.length > 80
        ? turn.prompt.slice(0, 80)
        : turn.prompt;

      const hasToolCalls = turn.steps.some((s) => s.toolCalls.length > 0);

      lines.push("[[responses]]");
      lines.push(`pattern = { type = "contains", text = "${tomlEscape(patternText)}" }`);

      if (!hasToolCalls) {
        // Simple case: just text response
        const allText = turn.steps.map((s) => s.text).filter(Boolean).join("\n");
        lines.push(`response = "${tomlEscape(allText)}"`);
      } else if (turn.steps.length === 1) {
        // Single step with tool calls
        lines.push("");
        emitResponseStep(lines, "responses.response", "response", turn.steps[0]);
      } else {
        // Multi-step: first step is the response, rest are turns
        lines.push("");
        emitResponseStep(lines, "responses.response", "response", turn.steps[0]);

        for (let i = 1; i < turn.steps.length; i++) {
          const step = turn.steps[i];
          if (!step.text && step.toolCalls.length === 0) continue;

          lines.push("[[responses.turns]]");
          lines.push('expect = { type = "any" }');
          lines.push("");
          emitResponseStep(lines, "responses.turns.response", "response", step);
        }
      }

      lines.push("");
    }
  }

  // Default catch-all response
  lines.push('[default_response]');
  lines.push('text = "I understand. Let me help with that."');

  // Tool execution mode
  if (turns && turnsHaveToolCalls(turns)) {
    lines.push("");
    lines.push("[tool_execution]");
    lines.push('mode = "mock"');
  }

  return lines.join("\n") + "\n";
}

// --- Generate Rust test files ---

interface CapshManifest {
  script: string;
  snapshots: string[];
}

function toRustIdent(name: string): string {
  return name.replace(/-/g, "_").replace(/\./g, "_");
}

function generateCapshSpecs(
  version: string,
  manifests: CapshManifest[],
  manifestArgs: Map<string, string>,
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const manifest of manifests) {
    const fnName = `capsh_${toRustIdent(manifest.script)}`;
    const snapshots = manifest.snapshots
      .map((s) => `"${s}"`)
      .join(", ");

    const argsStr = manifestArgs.get(manifest.script) || "";
    const extraArgs = argsStr
      ? argsStr.split(/\s+/).filter(Boolean).map((a) => `"${a}"`).join(", ")
      : "";

    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_capsh_spec("${version}", "${manifest.script}", &[${snapshots}], &[${extraArgs}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface TmuxFixture {
  script: string;
  snapshot: string;
}

function generateTmuxSpecs(
  version: string,
  fixtures: TmuxFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `tmux_${toRustIdent(fixture.script)}`;
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_tmux_spec("${version}", "${fixture.script}", &["${fixture.snapshot}"]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface CliFixture {
  name: string;
  args: string[];
}

function generateCliSpecs(
  version: string,
  fixtures: CliFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `cli_${toRustIdent(fixture.name)}`;
    const args = fixture.args.map((a) => `"${a}"`).join(", ");
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::assert_cli_starts_with("${version}", "${fixture.name}", &[${args}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// --- Main ---

const version = process.argv[2] || detectLatestVersion();
const fixturesDir = path.join(FIXTURES_BASE, version);

if (!fs.existsSync(fixturesDir)) {
  process.stderr.write(`Error: Fixtures directory not found: ${fixturesDir}\n`);
  process.exit(1);
}

console.log(`Generating specs for ${version}...`);

// Ensure output directories exist
fs.mkdirSync(path.join(SPECS_DIR, "capsh"), { recursive: true });
fs.mkdirSync(path.join(SPECS_DIR, "scenarios"), { recursive: true });
fs.mkdirSync(path.join(RUST_TESTS_DIR, "specs"), { recursive: true });

// --- 1. Discover capsh manifests ---

const manifests: CapshManifest[] = [];
const manifestFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".manifest.json"))
  .sort();

for (const f of manifestFiles) {
  const content = fs.readFileSync(path.join(fixturesDir, f), "utf-8");
  const manifest: CapshManifest = JSON.parse(content);
  manifests.push(manifest);
}

console.log(`Found ${manifests.length} capsh manifests`);

// --- 2. Generate simplified capsh scripts + scenarios ---

const capshSourceDir = path.join(CAPTURE_DIR, "capsh");
let generatedCapsh = 0;
const manifestArgs = new Map<string, string>();

for (const manifest of manifests) {
  const scriptName = manifest.script;
  const sourceScript = path.join(capshSourceDir, `${scriptName}.capsh`);

  if (!fs.existsSync(sourceScript)) {
    console.warn(`  Warning: Source script not found: ${scriptName}.capsh`);
    continue;
  }

  const originalContent = fs.readFileSync(sourceScript, "utf-8");
  const headers = parseHeaders(originalContent);

  manifestArgs.set(scriptName, headers.args);

  // Generate simplified capsh script
  const simplified = simplifyCapshScript(originalContent);
  fs.writeFileSync(
    path.join(SPECS_DIR, "capsh", `${scriptName}.capsh`),
    simplified,
  );

  // Extract conversation turns from session JSONL
  const turns = extractConversationTurns(fixturesDir, scriptName);

  // Generate scenario TOML
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${scriptName}.toml`);
  const scenario = generateScenario(scriptName, headers, version, manifest, fixturesDir, turns);
  fs.writeFileSync(scenarioPath, scenario);

  generatedCapsh++;
}

console.log(`Generated ${generatedCapsh} simplified capsh scripts + scenarios`);

// --- 3. Discover tmux fixtures ---

const tmuxFixtures: TmuxFixture[] = [];
const tmuxFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".tmux.txt"))
  .sort();

for (const f of tmuxFiles) {
  const snapshot = path.basename(f, ".tmux.txt");
  const script = snapshot.replace(/_/g, "-");
  tmuxFixtures.push({ script, snapshot });

  // Generate a scenario for tmux specs too
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${script}.toml`);
  if (!fs.existsSync(scenarioPath)) {
    const scenario = generateScenario(script, { args: "--model haiku", config: "trusted", timeout: null }, version, null, fixturesDir);
    fs.writeFileSync(scenarioPath, scenario);
  }
}

console.log(`Found ${tmuxFixtures.length} tmux fixtures`);

// --- 4. Discover CLI fixtures ---

const cliFixtures: CliFixture[] = [];
const cliSourceDir = path.join(CAPTURE_DIR, "cli");
const cliFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".cli.txt"))
  .sort();

for (const f of cliFiles) {
  const name = path.basename(f, ".cli.txt");
  const cliScript = path.join(cliSourceDir, `${name}.cli`);

  let args: string[] = [];
  if (fs.existsSync(cliScript)) {
    const content = fs.readFileSync(cliScript, "utf-8");
    args = content
      .split("\n")
      .filter((l) => l.trim() && !l.startsWith("#"))
      .join(" ")
      .trim()
      .split(/\s+/);
  } else {
    if (name === "version") args = ["--version"];
    else if (name === "help") args = ["--help"];
    else args = [name, "--help"];
  }

  cliFixtures.push({ name, args });
}

console.log(`Found ${cliFixtures.length} CLI fixtures`);

// --- 5. Generate Rust test files ---

const capshRust = generateCapshSpecs(version, manifests, manifestArgs);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "capsh_specs.rs"), capshRust);
console.log(`Generated capsh_specs.rs (${manifests.length} tests)`);

const tmuxRust = generateTmuxSpecs(version, tmuxFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "tmux_specs.rs"), tmuxRust);
console.log(`Generated tmux_specs.rs (${tmuxFixtures.length} tests)`);

const cliRust = generateCliSpecs(version, cliFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "cli_specs.rs"), cliRust);
console.log(`Generated cli_specs.rs (${cliFixtures.length} tests)`);

// --- Summary ---

const total = manifests.length + tmuxFixtures.length + cliFixtures.length;
console.log(`\nTotal: ${total} test functions generated`);
console.log(`  capsh: ${manifests.length}`);
console.log(`  tmux:  ${tmuxFixtures.length}`);
console.log(`  cli:   ${cliFixtures.length}`);
