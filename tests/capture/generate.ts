#!/usr/bin/env bun
// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC

//! Generate spec test files from capture fixtures.
//!
//! Reads:
//!   - tests/fixtures/v{VERSION}/*.manifest.json  (capsh script manifests)
//!   - tests/fixtures/v{VERSION}/*.cli.txt        (CLI output fixtures)
//!   - tests/fixtures/v{VERSION}/*.tmux.txt       (tmux fixtures)
//!   - tests/capture/capsh/*.capsh                (original capsh scripts)
//!   - tests/capture/cli/*.cli                    (CLI scripts)
//!   - tests/capture/tmux/*.sh                    (tmux scripts)
//!
//! Writes:
//!   - tests/specs/capsh/*.capsh                  (simplified capsh scripts)
//!   - tests/specs/scenarios/*.toml               (scenario files)
//!   - crates/cli/tests/capsh_specs.rs            (generated Rust tests)
//!   - crates/cli/tests/tmux_specs.rs             (generated Rust tests)
//!   - crates/cli/tests/cli_specs.rs              (generated Rust tests)

import * as fs from "node:fs";
import * as path from "node:path";

const SCRIPT_DIR = path.dirname(new URL(import.meta.url).pathname);
const ROOT = path.resolve(SCRIPT_DIR, "../..");
const FIXTURES_BASE = path.join(ROOT, "tests/fixtures");
const CAPTURE_DIR = path.join(ROOT, "tests/capture");
const SPECS_DIR = path.join(ROOT, "tests/specs");
const RUST_TESTS_DIR = path.join(ROOT, "crates/cli/tests");

const LICENSE_HEADER = `// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Alfred Jean LLC`;

const GENERATED_HEADER = `// AUTO-GENERATED by tests/capture/generate.ts — do not edit manually`;

// --- Detect latest fixture version ---

function detectLatestVersion(): string {
  const entries = fs
    .readdirSync(FIXTURES_BASE)
    .filter((e) => e.startsWith("v") && fs.statSync(path.join(FIXTURES_BASE, e)).isDirectory())
    .sort();
  if (entries.length === 0) {
    throw new Error("No fixture versions found in tests/fixtures/");
  }
  return entries[entries.length - 1];
}

// --- Parse capsh script headers ---

interface ScriptHeaders {
  args: string; // CLI args (empty string = default --model haiku)
  config: "trusted" | "welcome-back" | "auth-only" | "empty";
  timeout: number | null;
}

function parseHeaders(content: string): ScriptHeaders {
  const argsMatch = content.match(/^# Args:\s*(.*)$/m);
  let args = "--model haiku"; // default
  if (argsMatch) {
    const val = argsMatch[1].trim();
    if (val === "(none)" || val === "none") args = "";
    else args = val;
  }

  const configMatch = content.match(/^# Config:\s*(.*)$/m);
  let config: ScriptHeaders["config"] = "trusted";
  if (configMatch) {
    const val = configMatch[1].trim().split(/\s+/)[0];
    if (val === "welcome-back" || val === "auth-only" || val === "empty") {
      config = val;
    }
  }

  const timeoutMatch = content.match(/^# Timeout:\s*(\d+)/m);
  const timeout = timeoutMatch ? Number(timeoutMatch[1]) : null;

  return { args, config, timeout };
}

// --- Simplify capsh scripts ---

/**
 * Parse a duration string from capsh and return milliseconds.
 * Examples: "500" -> 500, "3s" -> 3000, "10s" -> 10000, "2m" -> 120000
 */
function parseDuration(s: string): number {
  if (s.endsWith("m")) return Number(s.slice(0, -1)) * 60000;
  if (s.endsWith("s")) return Number(s.slice(0, -1)) * 1000;
  if (s.endsWith("ms")) return Number(s.slice(0, -2));
  return Number(s);
}

/**
 * Format a duration in milliseconds as a capsh duration string.
 * Uses the most compact representation.
 */
function formatDuration(ms: number): string {
  if (ms >= 1000 && ms % 1000 === 0) return `${ms / 1000}s`;
  return `${ms}`;
}

/**
 * Clamp a wait-for-pattern timeout to max 5s (needs time for app startup + render).
 * Clamp a bare wait (duration) to max 500ms.
 * Clamp inline delays to max 100ms.
 */
function simplifyCapshScript(content: string): string {
  const lines = content.split("\n");
  const output: string[] = [];
  let inConditional = false;
  let inElse = false;
  let inMatch = false;
  let conditionalDepth = 0;

  for (const line of lines) {
    const trimmed = line.trim();

    // Skip empty lines and comments (keep header comments)
    if (trimmed === "" || trimmed.startsWith("#")) {
      output.push(line);
      continue;
    }

    // Handle if/else/end blocks — strip conditionals, keep the else branch
    // (the else branch is the "normal" path when claudeless is used, since
    // claudeless doesn't show trust dialogs by default)
    if (trimmed.startsWith("if wait")) {
      inConditional = true;
      inElse = false;
      conditionalDepth++;
      continue;
    }
    if (trimmed === "else" && inConditional) {
      inElse = true;
      continue;
    }
    if (trimmed === "end" && inConditional) {
      conditionalDepth--;
      if (conditionalDepth === 0) {
        inConditional = false;
        inElse = false;
      }
      continue;
    }
    if (inConditional && !inElse) {
      // Skip the if-branch
      continue;
    }
    if (inConditional && inElse) {
      // Keep the else-branch content (will be processed below)
      // Fall through to normal processing
    }

    // Handle match/end blocks — strip entirely (match arms are non-deterministic)
    if (trimmed.startsWith("match ")) {
      inMatch = true;
      continue;
    }
    if (trimmed === "end" && inMatch) {
      inMatch = false;
      continue;
    }
    if (inMatch) {
      // Inside match block — if this is an arm with a snapshot, extract it
      const armMatch = trimmed.match(/^"[^"]*"\s*->\s*(.+)$/);
      if (armMatch) {
        // Take the first arm's command as the default
        if (!output.some((l) => l.trim().startsWith("snapshot"))) {
          output.push(armMatch[1]);
        }
      }
      continue;
    }

    // Process wait commands
    if (trimmed.startsWith("wait ")) {
      const processed = simplifyWait(trimmed);
      output.push(processed);
      continue;
    }

    // Process send commands — clamp inline delays
    if (trimmed.startsWith("send ")) {
      const processed = simplifySend(trimmed);
      output.push(processed);
      continue;
    }

    // Keep everything else as-is (snapshot, kill)
    output.push(trimmed);
  }

  return output.join("\n");
}

/**
 * Simplify a wait command:
 * - `wait "pattern" 30s` → `wait "pattern" 5s`  (pattern waits need time for startup)
 * - `wait !"pattern" 10s` → `wait !"pattern" 5s`
 * - `wait 2s` → `wait 500`                       (bare delays just need to be short)
 * - `wait 100` → `wait 100` (already short)
 */
function simplifyWait(line: string): string {
  const trimmed = line.trim();

  // Bare wait with duration: `wait 500`, `wait 2s`
  const bareWaitMatch = trimmed.match(/^wait\s+(\d+(?:ms|s|m)?)$/);
  if (bareWaitMatch) {
    const ms = parseDuration(bareWaitMatch[1]);
    const clamped = Math.min(ms, 500);
    return `wait ${formatDuration(clamped)}`;
  }

  // Pattern wait: `wait "pattern" 10s` or `wait !"pattern" 10s`
  const patternWaitMatch = trimmed.match(/^(wait\s+!?"[^"]*")\s+(\d+(?:ms|s|m)?)$/);
  if (patternWaitMatch) {
    const prefix = patternWaitMatch[1];
    const ms = parseDuration(patternWaitMatch[2]);
    const clamped = Math.min(ms, 5000);
    return `${prefix} ${formatDuration(clamped)}`;
  }

  // Pattern wait without timeout: `wait "pattern"` — add a reasonable timeout
  const patternOnlyMatch = trimmed.match(/^wait\s+!?"[^"]*"$/);
  if (patternOnlyMatch) {
    return `${trimmed} 5s`;
  }

  return trimmed;
}

/**
 * Simplify a send command — clamp inline delays to 100ms.
 * `send "/help" 100 <Enter>` → `send "/help" 100 <Enter>` (already ≤100)
 * `send <C-u> 200 "/exit" 200 <Enter>` → `send <C-u> 100 "/exit" 100 <Enter>`
 */
function simplifySend(line: string): string {
  // Replace numeric tokens that are standalone delays (between quoted strings or key specials)
  return line.replace(/\s(\d+)\s/g, (match, num) => {
    const ms = Number(num);
    if (ms > 100) return ` 100 `;
    return match;
  });
}

// --- Extract placeholder text from fixture files ---

/**
 * Extract the placeholder text from a TUI fixture file.
 * Looks for `❯\xa0Try "..."` or `!\xa0Try "..."` patterns.
 */
function extractPlaceholder(fixturesDir: string, snapshotName: string): string | null {
  const fixturePath = path.join(fixturesDir, `${snapshotName}.tui.txt`);
  if (!fs.existsSync(fixturePath)) return null;

  const content = fs.readFileSync(fixturePath, "utf-8");
  // Match ❯ or ! followed by NBSP or space, then the placeholder text
  const match = content.match(/[❯!][\s\u00A0](Try "[^"]*")/);
  return match ? match[1] : null;
}

// --- Extract conversation turns from session JSONL files ---

interface ConversationTurn {
  prompt: string;       // user message content (string form)
  response: string;     // assistant text response
}

interface JsonlEntry {
  type: string;
  uuid?: string;
  parentUuid?: string | null;
  userType?: string;
  isMeta?: boolean;
  isApiErrorMessage?: boolean;
  message?: {
    role: string;
    content: string | Array<{ type: string; text?: string }>;
  };
  timestamp?: string;
}

/**
 * Extract user→assistant conversation turns from session JSONL files.
 * Reads all .jsonl files from {fixturesDir}/{scriptName}.projects/,
 * skipping subagents/, meta messages, errors, commands, and interrupts.
 */
function extractConversationTurns(fixturesDir: string, scriptName: string): ConversationTurn[] {
  const projectsDir = path.join(fixturesDir, `${scriptName}.projects`);
  if (!fs.existsSync(projectsDir)) return [];

  // Find all session JSONL files (skip subagents/)
  const jsonlFiles: string[] = [];
  for (const projDir of fs.readdirSync(projectsDir)) {
    const projPath = path.join(projectsDir, projDir);
    if (!fs.statSync(projPath).isDirectory()) continue;
    for (const file of fs.readdirSync(projPath)) {
      if (file.endsWith(".jsonl")) {
        const fullPath = path.join(projPath, file);
        if (!fullPath.includes("/subagents/")) {
          jsonlFiles.push(fullPath);
        }
      }
    }
  }

  const allTurns: ConversationTurn[] = [];

  for (const file of jsonlFiles) {
    const content = fs.readFileSync(file, "utf-8");
    const lines = content.split("\n").filter((l) => l.trim());

    // Parse all entries and build uuid→entry map
    const entries: JsonlEntry[] = [];
    const byUuid = new Map<string, JsonlEntry>();

    for (const line of lines) {
      try {
        const entry: JsonlEntry = JSON.parse(line);
        entries.push(entry);
        if (entry.uuid) {
          byUuid.set(entry.uuid, entry);
        }
      } catch {
        // Skip malformed lines
      }
    }

    // Collect assistant text responses, keyed by the user message uuid they respond to
    // Assistant messages come in streaming chunks: thinking first, then text.
    // The text chunk's parentUuid points to the thinking chunk, which points to the user message.
    const userTextByUuid = new Map<string, { prompt: string; timestamp: string }>();
    const responsesByUserUuid = new Map<string, string>();

    // First pass: index user messages
    for (const entry of entries) {
      if (entry.type !== "user" || !entry.uuid) continue;
      if (entry.isMeta) continue;
      if (entry.userType && entry.userType !== "external") continue;

      const text = extractMessageText(entry.message?.content);
      if (!text) continue;

      // Skip command messages
      if (text.includes("<command-name>") || text.includes("<local-command-caveat>") || text.includes("<local-command-stdout>")) continue;
      // Skip interrupted messages
      if (text.includes("[Request interrupted by user]")) continue;
      // Skip compact summaries
      if ((entry as any).isCompactSummary) continue;
      // Skip visible-in-transcript-only messages
      if ((entry as any).isVisibleInTranscriptOnly) continue;

      userTextByUuid.set(entry.uuid, { prompt: text, timestamp: entry.timestamp || "" });
    }

    // Second pass: find assistant text responses and trace back to user messages
    for (const entry of entries) {
      if (entry.type !== "assistant") continue;
      if (entry.isApiErrorMessage) continue;
      if (!entry.message?.content) continue;

      // Extract text content blocks
      const text = extractAssistantText(entry.message.content);
      if (!text) continue;

      // Trace back through parentUuid chain to find the originating user message
      const userUuid = traceToUser(entry, byUuid);
      if (!userUuid) continue;
      if (!userTextByUuid.has(userUuid)) continue;

      // Store response (last one wins for the same user message)
      responsesByUserUuid.set(userUuid, text);
    }

    // Build turns in timestamp order
    const fileTurns: Array<ConversationTurn & { timestamp: string }> = [];
    for (const [userUuid, { prompt, timestamp }] of userTextByUuid) {
      const response = responsesByUserUuid.get(userUuid);
      if (!response) continue;
      fileTurns.push({ prompt, response, timestamp });
    }

    fileTurns.sort((a, b) => a.timestamp.localeCompare(b.timestamp));
    allTurns.push(...fileTurns);
  }

  // Clean up prompts: strip embedded slash commands and control characters
  for (const turn of allTurns) {
    turn.prompt = cleanPrompt(turn.prompt);
  }

  // Filter out turns with empty prompts after cleanup
  const cleaned = allTurns.filter((t) => t.prompt.length > 0);

  // Deduplicate by prompt content (keep last occurrence from retries)
  const seen = new Map<string, ConversationTurn & { timestamp: string }>();
  for (const turn of cleaned) {
    seen.set(turn.prompt, turn as ConversationTurn & { timestamp: string });
  }

  // Sort by timestamp to maintain conversation order
  const result = [...seen.values()];
  result.sort((a, b) => (a.timestamp || "").localeCompare(b.timestamp || ""));

  return result;
}

/** Extract text from a user message content field (string or array). */
function extractMessageText(content: string | Array<{ type: string; text?: string }> | undefined): string | null {
  if (!content) return null;
  if (typeof content === "string") return content;
  if (Array.isArray(content)) {
    const texts = content
      .filter((b) => b.type === "text" && b.text)
      .map((b) => b.text!);
    return texts.length > 0 ? texts.join("\n") : null;
  }
  return null;
}

/** Extract text content from assistant message content blocks. */
function extractAssistantText(content: string | Array<{ type: string; text?: string }>): string | null {
  if (typeof content === "string") return content;
  if (Array.isArray(content)) {
    const texts = content
      .filter((b) => b.type === "text" && b.text)
      .map((b) => b.text!);
    return texts.length > 0 ? texts.join("\n") : null;
  }
  return null;
}

/** Trace an assistant entry back through parentUuid chain to find the originating user message uuid. */
function traceToUser(entry: JsonlEntry, byUuid: Map<string, JsonlEntry>): string | null {
  let current = entry;
  const visited = new Set<string>();

  for (let i = 0; i < 10; i++) {
    const parentUuid = current.parentUuid;
    if (!parentUuid) return null;
    if (visited.has(parentUuid)) return null; // cycle guard
    visited.add(parentUuid);

    const parent = byUuid.get(parentUuid);
    if (!parent) return null;

    if (parent.type === "user" && !parent.isMeta) {
      return parentUuid;
    }

    current = parent;
  }

  return null;
}

/**
 * Clean up a user prompt for pattern matching:
 * - Strip embedded slash commands (e.g., "\n/compact" at end of prompt)
 * - Strip control characters (e.g., Ctrl-U = \u0015)
 * - Trim whitespace
 */
function cleanPrompt(prompt: string): string {
  // Remove control characters (except newline)
  let cleaned = prompt.replace(/[\x00-\x09\x0B-\x1F\x7F]/g, "");

  // Split lines and remove lines that are slash commands
  const lines = cleaned.split("\n");
  const kept = lines.filter((line) => !line.trim().match(/^\/\w+/));
  cleaned = kept.join("\n").trim();

  return cleaned;
}

/** Escape a string for use in TOML double-quoted strings. */
function tomlEscape(s: string): string {
  return s
    .replace(/\\/g, "\\\\")
    .replace(/"/g, '\\"')
    .replace(/\n/g, "\\n")
    .replace(/\r/g, "\\r")
    .replace(/\t/g, "\\t");
}

// --- Generate scenario TOML files ---

interface ExistingResponse {
  patternText: string;
  response: string;
}

/**
 * Parse existing [[responses]] from a scenario TOML file.
 * Uses simple regex parsing — no TOML library needed.
 */
function parseExistingResponses(scenarioPath: string): ExistingResponse[] {
  if (!fs.existsSync(scenarioPath)) return [];

  const content = fs.readFileSync(scenarioPath, "utf-8");
  const responses: ExistingResponse[] = [];

  // Match [[responses]] blocks: pattern line followed by response line
  const blockRegex = /\[\[responses\]\]\s*\npattern\s*=\s*\{[^}]*text\s*=\s*"([^"]*)"[^}]*\}\s*\nresponse\s*=\s*"([^"]*)"/g;
  let match;
  while ((match = blockRegex.exec(content)) !== null) {
    responses.push({
      patternText: match[1].replace(/\\"/g, '"').replace(/\\n/g, "\n").replace(/\\\\/g, "\\"),
      response: match[2].replace(/\\"/g, '"').replace(/\\n/g, "\n").replace(/\\\\/g, "\\"),
    });
  }

  return responses;
}

function generateScenario(
  scriptName: string,
  headers: ScriptHeaders,
  version: string,
  manifest: CapshManifest | null,
  fixturesDir: string,
  turns?: ConversationTurn[],
  existingResponses?: ExistingResponse[],
): string {
  const lines: string[] = [];

  lines.push(`name = "${scriptName}"`);
  lines.push("");

  // Deterministic identity
  lines.push('session_id = "00000000-0000-0000-0000-000000000001"');
  lines.push('project_path = "/test/project"');
  lines.push('launch_timestamp = "2025-01-01T00:00:00Z"');
  lines.push('user_name = "TestUser"');

  // Claude version — always match the fixture version
  const versionNum = version.replace(/^v/, "");
  lines.push(`claude_version = "${versionNum}"`);

  // Provider — always "Claude API" (what real Claude shows)
  lines.push('provider = "Claude API"');

  // Default model — only set when no --model in args (i.e., Args: (none))
  if (headers.args === "") {
    // No CLI args at all — Claude defaults to Sonnet 4.5
    lines.push('default_model = "claude-sonnet-4-5-20250514"');
  }

  // Extract placeholder from first snapshot fixture
  if (manifest && manifest.snapshots.length > 0) {
    // Try ❯-style first, then !-style (bash mode)
    for (const snap of manifest.snapshots) {
      const placeholder = extractPlaceholder(fixturesDir, snap);
      if (placeholder) {
        lines.push(`placeholder = '${placeholder}'`);
        break;
      }
    }
  }

  lines.push("");

  // Trust setting based on config mode
  if (headers.config === "trusted") {
    lines.push("trusted = true");
  } else if (headers.config === "auth-only") {
    lines.push("trusted = false");
  } else if (headers.config === "welcome-back") {
    lines.push("trusted = true");
  }
  // empty config = no trust setting (triggers full onboarding)

  lines.push("");

  // Emit [[responses]] from extracted conversation turns (before default_response)
  if (turns && turns.length > 0) {
    for (const turn of turns) {
      // Extract a distinctive substring for pattern matching
      const patternText = turn.prompt.length > 80
        ? turn.prompt.slice(0, 80)
        : turn.prompt;

      lines.push("[[responses]]");
      lines.push(`pattern = { type = "contains", text = "${tomlEscape(patternText)}" }`);
      lines.push(`response = "${tomlEscape(turn.response)}"`);
      lines.push("");
    }
  }

  // Preserve existing manual [[responses]] that aren't covered by auto-generated ones
  if (existingResponses) {
    const autoPatterns = new Set((turns || []).map((t) => {
      const text = t.prompt.length > 80 ? t.prompt.slice(0, 80) : t.prompt;
      return text;
    }));

    for (const existing of existingResponses) {
      if (!autoPatterns.has(existing.patternText)) {
        lines.push("[[responses]]");
        lines.push(`pattern = { type = "contains", text = "${tomlEscape(existing.patternText)}" }`);
        lines.push(`response = "${tomlEscape(existing.response)}"`);
        lines.push("");
      }
    }
  }

  // Default catch-all response
  lines.push('[default_response]');
  lines.push('text = "I understand. Let me help with that."');

  return lines.join("\n") + "\n";
}

// --- Generate Rust test files ---

interface CapshManifest {
  script: string;
  snapshots: string[];
}

function toRustIdent(name: string): string {
  return name.replace(/-/g, "_").replace(/\./g, "_");
}

function generateCapshSpecs(
  version: string,
  manifests: CapshManifest[],
  manifestArgs: Map<string, string>,
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const manifest of manifests) {
    const fnName = `capsh_${toRustIdent(manifest.script)}`;
    const snapshots = manifest.snapshots
      .map((s) => `"${s}"`)
      .join(", ");

    // Get CLI args for this script
    const argsStr = manifestArgs.get(manifest.script) || "";
    const extraArgs = argsStr
      ? argsStr.split(/\s+/).filter(Boolean).map((a) => `"${a}"`).join(", ")
      : "";

    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_capsh_spec("${version}", "${manifest.script}", &[${snapshots}], &[${extraArgs}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface TmuxFixture {
  script: string; // tmux script name (e.g., "ctrl-c-exit-hint")
  snapshot: string; // fixture snapshot name (e.g., "ctrl_c_exit_hint")
}

function generateTmuxSpecs(
  version: string,
  fixtures: TmuxFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `tmux_${toRustIdent(fixture.script)}`;
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::run_tmux_spec("${version}", "${fixture.script}", &["${fixture.snapshot}"]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

interface CliFixture {
  name: string; // e.g., "help"
  args: string[]; // e.g., ["--help"]
}

function generateCliSpecs(
  version: string,
  fixtures: CliFixture[],
): string {
  const lines: string[] = [];
  lines.push(LICENSE_HEADER);
  lines.push("");
  lines.push(GENERATED_HEADER);
  lines.push("");
  lines.push("#![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]");
  lines.push("");
  lines.push("mod specs;");
  lines.push("");

  for (const fixture of fixtures) {
    const fnName = `cli_${toRustIdent(fixture.name)}`;
    const args = fixture.args.map((a) => `"${a}"`).join(", ");
    lines.push("#[test]");
    lines.push(`fn ${fnName}() {`);
    lines.push(
      `    specs::assert_cli_starts_with("${version}", "${fixture.name}", &[${args}]);`,
    );
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// --- Main ---

const version = process.argv[2] || detectLatestVersion();
const fixturesDir = path.join(FIXTURES_BASE, version);

if (!fs.existsSync(fixturesDir)) {
  process.stderr.write(`Error: Fixtures directory not found: ${fixturesDir}\n`);
  process.exit(1);
}

console.log(`Generating specs for ${version}...`);

// Ensure output directories exist
fs.mkdirSync(path.join(SPECS_DIR, "capsh"), { recursive: true });
fs.mkdirSync(path.join(SPECS_DIR, "scenarios"), { recursive: true });
fs.mkdirSync(path.join(RUST_TESTS_DIR, "specs"), { recursive: true });

// --- 1. Discover capsh manifests ---

const manifests: CapshManifest[] = [];
const manifestFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".manifest.json"))
  .sort();

for (const f of manifestFiles) {
  const content = fs.readFileSync(path.join(fixturesDir, f), "utf-8");
  const manifest: CapshManifest = JSON.parse(content);
  manifests.push(manifest);
}

console.log(`Found ${manifests.length} capsh manifests`);

// --- 2. Generate simplified capsh scripts + scenarios ---

const capshSourceDir = path.join(CAPTURE_DIR, "capsh");
let generatedCapsh = 0;
const manifestArgs = new Map<string, string>();

for (const manifest of manifests) {
  const scriptName = manifest.script;
  const sourceScript = path.join(capshSourceDir, `${scriptName}.capsh`);

  if (!fs.existsSync(sourceScript)) {
    console.warn(`  Warning: Source script not found: ${scriptName}.capsh`);
    continue;
  }

  const originalContent = fs.readFileSync(sourceScript, "utf-8");
  const headers = parseHeaders(originalContent);

  // Store CLI args for Rust test generation
  manifestArgs.set(scriptName, headers.args);

  // Generate simplified capsh script
  const simplified = simplifyCapshScript(originalContent);
  fs.writeFileSync(
    path.join(SPECS_DIR, "capsh", `${scriptName}.capsh`),
    simplified,
  );

  // Extract conversation turns from session JSONL
  const turns = extractConversationTurns(fixturesDir, scriptName);

  // Parse existing responses to preserve manual additions
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${scriptName}.toml`);
  const existingResponses = parseExistingResponses(scenarioPath);

  // Generate scenario TOML
  const scenario = generateScenario(scriptName, headers, version, manifest, fixturesDir, turns, existingResponses);
  fs.writeFileSync(scenarioPath, scenario);

  generatedCapsh++;
}

console.log(`Generated ${generatedCapsh} simplified capsh scripts + scenarios`);

// --- 3. Discover tmux fixtures ---

const tmuxFixtures: TmuxFixture[] = [];
const tmuxFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".tmux.txt"))
  .sort();

// Map tmux fixture snapshot names back to script names
// Convention: snapshot "ctrl_c_exit_hint" comes from script "ctrl-c-exit-hint"
for (const f of tmuxFiles) {
  const snapshot = path.basename(f, ".tmux.txt");
  // Convert snapshot_name back to script-name (underscores to hyphens)
  const script = snapshot.replace(/_/g, "-");
  tmuxFixtures.push({ script, snapshot });

  // Generate a scenario for tmux specs too
  const scenarioPath = path.join(SPECS_DIR, "scenarios", `${script}.toml`);
  if (!fs.existsSync(scenarioPath)) {
    const scenario = generateScenario(script, { args: "--model haiku", config: "trusted", timeout: null }, version, null, fixturesDir);
    fs.writeFileSync(scenarioPath, scenario);
  }
}

console.log(`Found ${tmuxFixtures.length} tmux fixtures`);

// --- 4. Discover CLI fixtures ---

const cliFixtures: CliFixture[] = [];
const cliSourceDir = path.join(CAPTURE_DIR, "cli");
const cliFiles = fs
  .readdirSync(fixturesDir)
  .filter((f) => f.endsWith(".cli.txt"))
  .sort();

for (const f of cliFiles) {
  const name = path.basename(f, ".cli.txt");
  const cliScript = path.join(cliSourceDir, `${name}.cli`);

  let args: string[] = [];
  if (fs.existsSync(cliScript)) {
    const content = fs.readFileSync(cliScript, "utf-8");
    args = content
      .split("\n")
      .filter((l) => l.trim() && !l.startsWith("#"))
      .join(" ")
      .trim()
      .split(/\s+/);
  } else {
    // Fallback: guess from name
    if (name === "version") args = ["--version"];
    else if (name === "help") args = ["--help"];
    else args = [name, "--help"];
  }

  cliFixtures.push({ name, args });
}

console.log(`Found ${cliFixtures.length} CLI fixtures`);

// --- 5. Generate Rust test files ---

const capshRust = generateCapshSpecs(version, manifests, manifestArgs);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "capsh_specs.rs"), capshRust);
console.log(`Generated capsh_specs.rs (${manifests.length} tests)`);

const tmuxRust = generateTmuxSpecs(version, tmuxFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "tmux_specs.rs"), tmuxRust);
console.log(`Generated tmux_specs.rs (${tmuxFixtures.length} tests)`);

const cliRust = generateCliSpecs(version, cliFixtures);
fs.writeFileSync(path.join(RUST_TESTS_DIR, "cli_specs.rs"), cliRust);
console.log(`Generated cli_specs.rs (${cliFixtures.length} tests)`);

// --- Summary ---

const total = manifests.length + tmuxFixtures.length + cliFixtures.length;
console.log(`\nTotal: ${total} test functions generated`);
console.log(`  capsh: ${manifests.length}`);
console.log(`  tmux:  ${tmuxFixtures.length}`);
console.log(`  cli:   ${cliFixtures.length}`);
